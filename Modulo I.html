<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>M&oacute;dulo I</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="mÃ³dulo-i">MÃ³dulo I</h1>
<p>ğŸ¯ <strong>Clases 1 y 2:</strong> <em>Conceptos bÃ¡sicos. ComunicaciÃ³n y sincronizaciÃ³n. Interferencia.</em></p>
<ul>
<li><a href="#m%C3%B3dulo-i">MÃ³dulo I</a>
<ul>
<li><a href="#programa-concurrente-estados-acciones-e-historias">Programa concurrente: estados, acciones e historias</a></li>
<li><a href="#acciones-at%C3%B3micas">Acciones atÃ³micas</a></li>
<li><a href="#propiedad-asv">Propiedad ASV</a></li>
<li><a href="#sincronizaci%C3%B3n">SincronizaciÃ³n</a>
<ul>
<li><a href="#especificaci%C3%B3n">EspecificaciÃ³n</a></li>
</ul>
</li>
<li><a href="#propiedades">Propiedades</a></li>
<li><a href="#scheduling-y-fairness">Scheduling y Fairness</a>
<ul>
<li><a href="#fairness-incondicional">Fairness incondicional</a></li>
<li><a href="#fairness-d%C3%A9bil">Fairness dÃ©bil</a></li>
<li><a href="#fairness-fuerte">Fairness fuerte</a></li>
<li><a href="#ejemplo">Ejemplo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="programa-concurrente-estados-acciones-e-historias">Programa concurrente: estados, acciones e historias</h2>
<p>El <strong><em>estado</em></strong>, de un programa concurrente, consiste en los valores de las variables del programa en un instante de tiempo dado. Pudiendo ser, variables explÃ­citas (las definidas por el programador) como variables implÃ­citas (<em>program counter</em>, <em>stack pointer</em>, etc ...).</p>
<p>La ejecuciÃ³n, del programa concurrente, puede ser vista como el intercalado de secuencias de <strong><em>acciones atÃ³micas</em></strong> ejecutadas por cada proceso. AsÃ­, cada ejecuciÃ³n particular del programa puede ser vista como una <strong><em>historia (trace)</em></strong>: S<sub>1</sub> â†’ S<sub>2</sub> â†’ ... S<sub>n</sub>.</p>
<p>Cada ejecuciÃ³n de un programa concurrente, produce una historia. Inclusive, hasta en los programas mÃ¡s triviales, el nÃºmero de historias posibles puede ser enorme. Por ejemplo; para el siguiente programa existen 2 (dos) historias posibles:</p>
<pre><code><code><div>var x = 5; // (a)

co
    x = 0; // (b)
    x = x + 1; // (c)
oc
</div></code></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">Historia</th>
<th style="text-align:center">Valor X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">A â†’ B â†’ C</td>
<td style="text-align:center"><code>x = 1</code></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">A â†’ C â†’ B</td>
<td style="text-align:center"><code>x = 0</code></td>
</tr>
</tbody>
</table>
<h2 id="acciones-atÃ³micas">Acciones atÃ³micas</h2>
<p>Una <strong><em>acciÃ³n atÃ³mica</em></strong>, es una acciÃ³n que realiza un cambio de estado indivisible. Esto significa que, cualquier estado intermedio que pueda existir en la implementaciÃ³n de la acciÃ³n no debe ser visible a los otros procesos.</p>
<p>Una <strong><em>acciÃ³n atÃ³mica de grano fino</em></strong>, es aquella implementada por el hardware (CPU) en el cual el programa concurrente es ejecutado.</p>
<p>En un programa secuencial, las sentencias de asignaciÃ³n parecen ser atÃ³micas. Esto es porque ningÃºn estado intermedio es visible al programa. En los programas concurrentes, no se puede afirmar lo mismo. Una sentencia de asignaciÃ³n, puede estar implementada por una secuencia de instrucciones mÃ¡quina de grano fino. Por ejemplo, para el siguiente programa.</p>
<pre><code><code><div>var y = 0;
var z = 0;

co 
    x = y + z; // (a) load x,y; (b) sum x,z;
    y = 1; // (c) 
    z = 2; // (d)
oc
</div></code></code></pre>
<p>Asumiendo que la sentencia  <code>x = y + z</code>, a nivel mÃ¡quina, es implementada con las instrucciones atÃ³micas <code>load</code> y <code>sum</code>; podemos sostener que su ejecuciÃ³n no serÃ¡ atÃ³mica, ya que eventualmente podrÃ¡ ser interrumpida. Esto se ve en, algunas de, las posibles historias del programa.</p>
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">Historia</th>
<th style="text-align:center">Valor X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">A â†’ B â†’ C â†’ D</td>
<td style="text-align:center"><code>x = 0</code></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">C â†’ A â†’ B â†’ D</td>
<td style="text-align:center"><code>x = 1</code></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">A â†’ C â†’ D â†’ B</td>
<td style="text-align:center"><code>x = 2</code></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">C â†’ D â†’ A â†’ B</td>
<td style="text-align:center"><code>x = 3</code></td>
</tr>
</tbody>
</table>
<p>En todas las historias, la ejecuciÃ³n de B antecede a la de A (<code>x = y + z</code>). Lo cual, es deseable. Excepto en la historia nÃºmero 3, donde se observa una interferencia.</p>
<p>La <strong><em>interferencia</em></strong>, es un evento negativo. El cual se produce, cuando un proceso toma una acciÃ³n que invalida las suposiciones hechas por otro proceso. TÃ©cnicas para evitar la interferencia, pueden ser:</p>
<ol>
<li>Variables disjuntas (disjoint variables)</li>
<li>Afirmaciones debilitadas (weakened assertions)</li>
<li>Invariantes globales (global invariants)</li>
<li>SincronizaciÃ³n (synchronization)</li>
</ol>
<h2 id="propiedad-asv">Propiedad ASV</h2>
<p>Una forma de detectar que una sentencia no posee interferencias y, por consiguiente, su ejecuciÃ³n parecerÃ¡ atÃ³mica es verificar que la misma posea, a lo sumo, una referencia crÃ­tica.</p>
<p>Una <strong><em>referencia crÃ­tica</em></strong>, en una expresiÃ³n, es la referencia a una variable que es modificada por otro proceso. Toda expresiÃ³n que contenga a lo sumo una referencia crÃ­tica, cumple con la <strong><em>propiedad  &quot;a lo sumo una vez&quot;</em></strong> y su ejecuciÃ³n parecerÃ¡ atÃ³mica.</p>
<p>Por ejemplo, la sentencia de asignaciÃ³n <em>x = expr</em> satisface la propiedad si se cumple alguna de las siguientes condiciones:</p>
<ol>
<li>Si <em>expr</em> contiene a lo sumo una referencia crÃ­tica, en cuyo caso <em>x</em> no podrÃ¡ ser leÃ­da por otro proceso.</li>
<li>Si <em>expr</em> no contiene referencias crÃ­ticas, en cuyo caso <em>x</em> podrÃ¡ ser leÃ­da por otro proceso.</li>
</ol>
<pre><code><code><div>    Program Uno;        |   Program Dos;        |   Program Tres;
                        |                       |
    var x = 0;          |   var x = 0;          |   var x = 0;
    var y = 0;          |   var y = 0;          |   var y = 0;
                        |                       |
    co  x = x + 1; (a)  |   co  x = y + 1; (a)  |   co  x = y + 1; (a)
    //  y = y + 1; (b)  |   //  y = y + 1; (b)  |   //  y = x + 1; (b)
    oc                  |   oc                  |   oc
</div></code></code></pre>
<p>ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§</p>
<p>ğŸš§  VERIFICAR HISOTIRAS Y CONSULTAR POR QUE HAY INTERFERENCIA EN 3</p>
<p>ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§</p>
<p>âœ… <strong>Program Uno</strong></p>
<ul>
<li>La sentencia del proceso A, no posee referencias crÃ­ticas.</li>
<li>La sentencia del proceso B, no posee referencias crÃ­ticas.</li>
</ul>
<p>âœ… <strong>Program Dos</strong></p>
<ul>
<li>La sentencia del proceso A, contiene una referencia crÃ­tica en <code>y + 1</code>. No obstante, <code>x</code> no es leÃ­da por otro proceso.</li>
<li>La sentencia del proceso B, no posee referencias crÃ­ticas.</li>
</ul>
<p>âŒ <strong>Program Tres</strong></p>
<ul>
<li>La sentencia del proceso A, contiene una referencia crÃ­tica en <code>y + 1</code> y <code>x</code> es leÃ­da por otro proceso.</li>
<li>La sentencia del proceso B, contiene una referencia crÃ­tica en <code>x + 1</code> e <code>y</code> es leÃ­da por otro proceso.</li>
</ul>
<p>ğŸ“Œ La propiedad tambiÃ©n aplica para expresiones que, no sean de asignaciÃ³n.</p>
<p>ğŸ“Œ Se asume que, en el proceso A del <strong>program dos</strong>, leer <code>y</code> antes o despues de su actualizaciÃ³n es indistinto.</p>
<h2 id="sincronizaciÃ³n">SincronizaciÃ³n</h2>
<p>La interacciÃ³n entre los procesos, conlleva a una gran cantidad de historias posibles, como se vio en secciones anteriores. No obstante, no todas las historias posibles son deseables. Por ejemplo, una expresiÃ³n que no satisfaga ASV provocarÃ¡ una historia no deseada.</p>
<p>En general, es deseable, ejecutar secuencias de instrucciones como una Ãºnica acciÃ³n atÃ³mica que prevengan intercalados no deseados. A estas secuencias de instrucciones las llamaremos <strong>acciones atÃ³micas de grano grueso</strong>.</p>
<p>El rol de la <strong>sincronizaciÃ³n</strong>, es la de permitir la construcciÃ³n de estas acciones atÃ³micas de grano grueso. Y asÃ­ evitar la interferencia entre procesos.</p>
<ol>
<li>SincronizaciÃ³n por <strong>exlusiÃ³n mutua (mutex)</strong></li>
<li>SincronizaciÃ³n por <strong>condiciÃ³n (barrier)</strong></li>
</ol>
<h3 id="especificaciÃ³n">EspecificaciÃ³n</h3>
<p>ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§
LEER EN EL LIBRO
ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§</p>
<h2 id="propiedades">Propiedades</h2>
<p>Una propiedad, en un programa concurrente, es un atributo que debe ser cierto en cada historia posible del programa. Existen 2 (dos) grandes categorÃ­as, de propiedades.</p>
<p>La primera, es la de <strong>seguridad (safety)</strong>. La cual, debe asegurar que nada malo ocurra durante la ejecuciÃ³n; para garantizar que el estado final del programa sea el correcto. Dos propiedades fundamentales, dentro de esta categorÃ­a, son:</p>
<ol>
<li><strong>ExclusiÃ³n mutua:</strong> El evento negativo, en este caso, serÃ­a que 2 (dos) o mÃ¡s programas; accedan a la misma secciÃ³n crÃ­tica en el mismo instante de tiempo.</li>
<li><strong>Ausencia de deadlock:</strong> El evento negativo, en este caso, serÃ­a que un proceso quede demorado, esperando por una condiciÃ³n que nunca serÃ¡ verdadera.</li>
</ol>
<p>La segunda, es la de <strong>vida (liveness)</strong>. La cual, debe asegurar que eventualmente algo bueno ocurrirÃ¡; para garantizar la correcta terminaciÃ³n del programa. Por ejemplo:</p>
<ol>
<li>Que todo proceso,eventualmente, acceda a su secciÃ³n crÃ­tica.</li>
<li>Que todo mensaje, eventualmente, sea recibido por su receptor.</li>
</ol>
<h2 id="scheduling-y-fairness">Scheduling y Fairness</h2>
<p>La mayorÃ­a de las propiedades de vida, de un programa concurrente, dependen del <strong>fairness</strong>. El cual, es un concepto, que se ocupa de garantizar que todos los procesos tienen chances de proceder sin importar lo que hagan los demÃ¡s.</p>
<p>Para que los procesos avancen, acciones atÃ³micas candidatas deben ser elegidas para su ejecuciÃ³n. Dicha tarea de selecciÃ³n, es llevada a cabo por una polÃ­tica de planificaciÃ³n (<strong>scheduling policy</strong>). SegÃºn la bibliografÃ­a, existen 3 (tres) grados de fairness que toda polÃ­tica de planificaciÃ³n deberÃ­a proveer.</p>
<p>ğŸ’¡ El programa es ejecutado en una arquitectura monoprocesador.</p>
<h3 id="fairness-incondicional">Fairness incondicional</h3>
<p>Una polÃ­tica de planificaciÃ³n cumple con este grado si cada acciÃ³n atÃ³mica, incondicional elegible, eventualmente es ejecutada.</p>
<pre><code><code><div>var continue = true;
co  while (continue); (P)
/   continue = false; (Q)
oc 
</div></code></code></pre>
<p>Una polÃ­tica donde se conceda CPU, a los procesos, hasta que estos terminan o son demorados; no serÃ­a incondicionalmente fair. Ya que si (P) ingresa primero entonces, (Q) no tendrÃ­a oportunidad de ser ejecutada.</p>
<p>Por el contrario, Round Robin si resulta una polÃ­tica incondicionalmente fair. Ya que, (Q) eventualmente podrÃ¡ acceder a CPU.</p>
<h3 id="fairness-dÃ©bil">Fairness dÃ©bil</h3>
<p>Una polÃ­tica de planificaciÃ³n cumple este grado si, es incondicionalmente fair y cada acciÃ³n atÃ³mica condicional eventualmente es ejecutada. Asumiendo que su condiciÃ³n, se volverÃ¡ verdadera y permanecerÃ¡ asÃ­ hasta ser vista por el proceso ejecutando la acciÃ³n.</p>
<h3 id="fairness-fuerte">Fairness fuerte</h3>
<p>Una polÃ­tica de planificaciÃ³n cumple este grado si, es incondicionalmente fair y cada acciÃ³n atÃ³mica condicional eventualmente es ejecutada. Asumiendo que su condiciÃ³n, se volverÃ¡ verdadera con infinita frecuencia hasta ser vista por el proceso ejecutando la acciÃ³n.</p>
<p>âš ï¸ No es posible idear un planificador que sea prÃ¡ctico y fuertemente fair.</p>
<h3 id="ejemplo">Ejemplo</h3>
<p>Â¿Este programa termina?</p>
<pre><code><code><div>var continue = true;
var try = false;

co  while (continue) { try = true; try = false; } (P)
/   &lt; await(try) continue = false &gt; (Q)
oc
</div></code></code></pre>
<p>Con una polÃ­tica dÃ©bilmente fair, el programa podrÃ­a no terminar. Ya que, <code>try</code> no se mantiene verdadera hasta ser vista por (Q).</p>
<p>Con una polÃ­tica fuertemente fair, el programa podrÃ­a terminar. Ya que, <code>try</code> se convierte en verdadera con infinita frecuencia.</p>

    </body>
    </html>