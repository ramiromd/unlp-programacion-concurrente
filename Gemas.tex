\documentclass[a4paper, 10pt]{article}
\usepackage{common}
\usepackage{enumitem}
\newenvironment{QandA}{
    \begin{enumerate}\bfseries}
    {\end{enumerate}
}
\newenvironment{answered}{\par\normalfont}{}
\pagestyle{empty}

\begin{document}
    
% Carátula
\title{
    \faIcon[regular]{gem}\\
    Programación Concurrente\\
    \large Preguntas de final
}

\author{Ramiro Martínez D'Elía}
\date{2021}
\maketitle

\noindent%
\begin{QandA}
\item Defina programa concurrente, programa paralelo y programa distribuido.
\begin{answered}
    \emph{Apunte I: sección 1.1, Apunte II: sección 1.1 y Apunte IV: 1.1}
\end{answered}

%========================================================================

\item Responda
\begin{enumerate}[label=\alph*)]
\item ¿A qué se denomina propiedad del programa? ¿Qué son las propiedades de seguridad y vida? Ejemplificar.
\begin{answered}
    \emph{Apunte I: sección 1.1, Apunte II: sección 1.1 y Apunte IV: 1.1}
\end{answered}
\item Defina fairness. Relacionar dicho concepto con las políticas de scheduling.
\begin{answered}
    \emph{Apunte I: sección 1.7}
\end{answered}
\item Describa los distintos tipos de fairness
\begin{answered}
    \emph{Apunte I: sección 1.8}
\end{answered}
\item ¿Cuáles son las propiedades que debe cumplir un protocolo de E/S a una sección crítica?
\begin{answered}
    \emph{Apunte II: sección 1.2}
\end{answered}
\item Cuáles son los defectos que presenta la sincronización por busy waiting? Diferencie esta situación respecto de los semáforos.
\begin{answered}
    \emph{Apunte II: sección 2.3}
\end{answered}
\item Explique la semántica de la instrucción de grano grueso  AWAIT y su relación con las instrucciones Test \& Set o Fetch \& Add.
\begin{answered}
    \emph{Apunte I: sección 1.6}
\end{answered}
\end{enumerate}

%===================================================================================================

\item Definir el problema general de alocación de recursos y su resolución mediante una política SJN. ¿Minimiza el tiempo promedio de espera? ¿Es fair? Si no lo es, plantee una alternativa que lo sea.
\begin{answered}
    \emph{Apunte II: sección 3.5.2}
\end{answered}

%===================================================================================================

\item ¿En qué consiste la técnica de passing the baton? Aplicar este concepto a la resolución del problema de lectores y escritores.
\begin{answered}
    \emph{Apunte II: sección 3.5 y 3.5.1}
\end{answered}

%===================================================================================================

\item Explique el concepto de broadcast y sus dificultades de implementación en un ambiente distribuido, con pasaje de mensajes sincrónico y asincrónico.
\begin{answered}
\emph{Sobre primitiva broadcast $\rightarrow$ Apunte III: sección 2.1.4}

En un ambiente con memoria compartida, este tipo de primitivas es más sencilla de implementar. 

En ambientes distribuidos, al no haber variables compartidas, se debe utilizar Pasaje de Mensajes. Esto, supone ciertas dificultades para cada caso.

Con PMA:
\begin{itemize}
    \item Utilizar un único canal. El emisor deberá enviar tantos mensajes, como receptores existan. $\rightarrow$ Evita demoras inecesarias.
    \item Un canal por proceso. El emisor deberá enviar el mensaje por tantos canales, como receptores existan. $\rightarrow$ Causa demoras innesecarias: un proceso listo debe esperar a que el emisor itere sobre su canal. 
\end{itemize}

Con PMS:

Los canales son punto a punto. Por este motivo, solo podemos llevar a cabo la implementación PMA(2). Aunque, en este caso, resulte aún más ineficiente ya que \lstinline{send} causa demora.
\end{answered}

%====================================================================================================

\item Sobre exclusión mutua selectiva

\begin{enumerate}[label=\alph*)]
\item ¿Por qué el problema de los filósofos es de exclusión mutua selectiva? Si en lugar de 5 filósofos fueran 3, ¿el problema seguiría siendo de exclusión mutua selectiva? ¿Por qué?
\begin{answered}
    \emph{Apunte II: sección 3.4.1}
\end{answered}
\item El problema de los filósofos resuelto de forma centralizada y sin posiciones fijas ¿es de exclusión mutua selectiva? ¿Por qué?
\begin{answered}
    \emph{Apunte II: sección 3.4.1}
\end{answered}
\item El problema de los lectores-escritores es de exclusión mutua selectiva? ¿Porque?
\begin{answered}
    \emph{Apunte II: sección 3.4.2}
\end{answered}
\item Si en el problema de los lectores-escritores se acepta sólo 1 escritor  o 1 lector en la BD, ¿tenemos un problema de exclusión mutua selectiva?  ¿Por qué?
\begin{answered}
    \emph{Apunte II: sección 3.4.2}
\end{answered}
\end{enumerate}

%=====================================================================================================

\item Sea el problema en el cual N procesos poseen inicialmente cada uno un valor V, y el objetivo es que todos conozcan cual es el máximo y cuál es el mínimo de todos los valores.

\begin{enumerate}[label=\alph*)]
\item Plantee conceptualmente posibles soluciones con las siguientes arquitecturas de red: Centralizada, simétrica y anillo circular. No implementar.
\begin{answered}
    \emph{Apunte III: sección 2.1}
\end{answered}
\item Analice las soluciones anteriores desde el punto de vista del número de mensajes y la performance global del sistema.
\begin{answered}
    \emph{Apunte II: sección 2.1.4}
\end{answered}
\end{enumerate}

%======================================================================================================

\item Defina el concepto de granularidad. ¿Qué relación existe entre la granularidad de programas y de procesadores?
\begin{answered}
    \emph{Apunte IV: sección 1.6}
\end{answered}

%========================================================================================================

\item Dado el siguiente programa concurrente con memoria compartida, y suponiendo que todas las variables están inicializadas en 0 al empezar el programa, y que las instrucciones no son atómicas. Para cada una de las opciones indique verdadero o falso. En caso de ser verdadero indique el camino de ejecución para llegar a ese valor y de ser falso justifique claramente su respuesta.

\begin{multicols}{3}
\begin{lstlisting}
P1::            
If ( x == 0 ) then
    Y = 4*x+2;
    X = y+2+x;
\end{lstlisting}
\columnbreak
\begin{lstlisting}
P2::            
If ( x > 0 ) then
    X = X + 1;
\end{lstlisting}
\columnbreak
\begin{lstlisting}
P3::            
X = x*8+x*2+1;
\end{lstlisting}
\end{multicols}

\begin{enumerate}[label=\alph*)]
\item El valor de x al terminar el programa es 9.
\begin{answered}
\emph{Instrucciones no atómicas $\rightarrow$ los bloques IF pueden ser interrumpidos\\} 
Verdadero para la siguiente historia:\\
$P1_2 \rightarrow P2 \rightarrow P3 (x=1) \rightarrow P1_3 (y=2) \rightarrow P1_4 (x=9)$
\end{answered}
\item El valor de x al terminar el programa es 6.
\begin{answered}
Verdadero para la siguiente historia:\\
$P1_2 \rightarrow P1_3 (y=2) \rightarrow P3 (x=1) \rightarrow P1_4 (x=5) \rightarrow P2 (x=6)$
\end{answered}
\item El valor de x al terminar el programa es 11.
\begin{answered}
Falso: la única forma de que ocurra es que $x=1$ cuando se ejecute P3. Esto no puede darse, ya que P2 nunca podría incrementar con $x=0$ y P1 escribe valores mayores sobre $x$.
\end{answered}
\item Y, siempre termina con alguno de los siguientes valores: 10 o 6 o 2 o 0.
\begin{answered}
\begin{itemize}
\item $y=10$ con $P1_2 \rightarrow P3 (x=1) \rightarrow P2 (x=2) \rightarrow P1_3 (y=10) \rightarrow P1_4 (x=8)$
\item $y=6$ con $P1_2 \rightarrow P2 \rightarrow P3 (x=1) \rightarrow P1_3 (y=6) \rightarrow P1_4 (x=9)$
\item $y=2$ con cualquier historia que inicie con $P1_2 \rightarrow P1_3$. Una vez seteado $y$, ningún otra instrucción la modifica.
\item $y=0$ con cualquier historia que inicie con $P3$. Ya que $x=1$ invalidará el if de P1.
\end{itemize}
\end{answered}
\end{enumerate}

%=====================================================================================================

\item ¿En qué consiste la comunicación guardada (introducida por CSP) y cuál es su utilidad?
\begin{answered}
    \emph{Apunte III: sección 3.1}
\end{answered}

%=====================================================================================================

\item ¿Cuál es la utilidad de la técnica de passing the baton? ¿Qué relación encuentra con la técnica de passing the condition?
\begin{answered}
    \emph{Apunte II: sección 3.5}
\end{answered}

%=====================================================================================================

\item Explique sintéticamente los 7 paradigmas de interacción entre procesos en programación distribuida. Ejemplifique.
\begin{answered}
    \emph{Apunte III: capitulo 5}
\end{answered}

%=====================================================================================================

\item Responder sobre programación paralela
\begin{enumerate}
    \item ¿Cuál es el objetivo de la programación paralela?
    \begin{answered}
        \emph{Apunte IV: sección 1.1}
    \end{answered}
    \item Defina las métricas de speedup y eficiencia. ¿Cuál es el significado de cada una de ellas (que miden)? ¿Cuál es el rango de valores para cada una?
    \begin{answered}
        \emph{Apunte IV: sección 1.2 y sección 1.3}
    \end{answered}
    \item ¿En qué consiste la ley de Amdahl?
    \begin{answered}
        \emph{Apunte IV: sección 1.5}
    \end{answered}
\end{enumerate}

%=======================================================================================================

\item Suponga que quiere ordenar N números enteros utilizando pasaje de mensajes con el siguiente algoritmo (odd/even Exchange sort): Hay  n procesos P [1: n], con n par. Cada proceso ejecuta una serie de rondas. En las rondas impares, los procesos con número impar P[impar] intercambian valores con P [impar +1] si los números están desordenados. En las rondas pares, los procesos con numero par P[par] intercambian valores con P [par +1] si los números están desordenados (P [1] y P[n] no hacen nada en las rondas pares).
\begin{enumerate}
\item Determine cuantas rondas deben ejecutarse en el peor caso para ordenar los números.
\begin{answered}
El peor de los casos es que los números estén ordenados de mayor a menor (o viceversa). En dicho caso, haran falta $n$ rondas para intercambiar todos los valores.
\\
Por ejemplo, para la siguiente lista ${6,5,4,3,2,1}$ con $n=6$.
\\
$R_1 = 6_1 \rightarrow 5_2 4_3 \rightarrow 3_4 2_5 \rightarrow 1_6$
\\
$R_2 = 5_1 6_2 \rightarrow 3_3 4_4 \rightarrow 1_5 2_6$
\\
$...$
\\
$R_6 = 1_1 3_2 \rightarrow 2_3 5_4 \rightarrow 4_5 6_6$
\end{answered}
\item ¿Considere que es más adecuado para este caso, si pasaje de mensajes sincrónico o asincrónico? Justifique.
\begin{answered}
Debido a que los procesos deben sincronizar entre pares, PMS parece una mejor opción. Ya que, la primitiva send es bloquante y genera una barrera de forma implícita.
\\
De utilizar PMA, habría que implementar una barrera entre pares de procesos de forma explícita.
\end{answered}
\end{enumerate}
\item Escriba un algoritmo paralelo para ordenar el arreglo a [1: n] en forma ascendente. ¿Cuántos mensajes se utilizan? 
\begin{answered}
\begin{minipage}[t]{.5\linewidth}
\begin{lstlisting}
Process P1
const mayor = n/2;
int nuevo,
    a1[1:n/2];

# ordenar a1 de forma ascendente

P2 ! (a1[mayor]);
P2 ? (nuevo);

do (true) a1[mayor] > nuevo ->
    # reordenar a1:
    # decartando a1[mayor]
    P2 ! (a1[mayor]);
    P2 ? (nuevo)
od
end;
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.5\linewidth}
\begin{lstlisting}
Process P2
const menor = 1;
int nuevo,
    a1[1:n/2];

# ordenar a1 de forma ascendente

P1 ? (nuevo);
P1 ! (a1[menor]);

do (true) a1[menor] < nuevo ->
    # reordenar a1:
    # descartando a1[menor]
    P1 ? (nuevo);
    P1 ! (a2[menor]);
od
end;
\end{lstlisting}
\end{minipage}

Notar como las líneas 14 y 15 generan una barrera entre procesos. (agregar un dibujo como el del cuaderno)
\end{answered}
\begin{enumerate}[label=\alph*)]
\item ¿Cuántos mensajes intercambian en el mejor de los casos? ¿Y en el peor de los casos?
\begin{answered}
En el mejor de los casos, la lista ya se encuentra ordenada, solo se intercambiarán 2 valores (uno cada proceso). Los valores enviados, no satisfacen la condición del do.

En el peor de los casos, la lista esta ordenada de mayor a menor, todos los valores son intercambiados ($n/2$ cada proceso). Esto implica un total de $n$ mensajes.
\end{answered}
\end{enumerate}

{\large \textbf{\\Implemente una solución, paralela, al problema de multiplicación de matrices de $n*n$ con $P<n$}}

Si el número de procesos es menor que \emph{n}, no podremos asignar una fila a cada proceso. En su lugar, debemos hacer que cada proceso trabaje con una porción (\emph{strpe}) del arreglo.

\begin{lstlisting}
Process[w = 1..P]

# El proceso w, procesara las filas first a last
int first = (w-1) * (n/p) + 1;
int last = first + n/p - 1;

for(a_row = first to last)

    for [b_col = 1 to n]
        # Inicializamos la celda acumuladora de C.
        c[a_row, b_col] = 0;

        # Iteramos entre las columnas (A) y filas (B) de interes.
        for [k = 1 to n]
            c[a_row, b_col] = c[a_row, b_col] + (a[a_row, k] * b[k, b_row]);
end;
End;
\end{lstlisting}

\textbf{(a) Suponga n=128 y que cada procesador es capaz de ejecutar un proceso. ¿Cuántas asignaciones, sumas y productos se hacen secuencialmente (caso en el que P=1)?}

\begin{itemize}
    \item En este caso $strip \rightarrow n$
    \item Línea 11: Hace tantas pasadas como columnas tenga B ($n$) por el tamaño del strip $\rightarrow n^2$
    \item Línea 15: Hace $n$ pasadas por tantas pasadas como columnas tenga B por el tamaño del strip $\rightarrow n^3$
\end{itemize}

$Asignaciones = n^3 + n^2 = 128^3 + 128^2 = 2097152 + 16384 = 2113536$

$Sumas = n^3 = 128^3 = 2097152$

$Productos = n^3 = 128^3 = 2097152$


\textbf{(b) Manteniendo n=128. Si los procesadores P1 a P7 son iguales, y sus tiempos de asignación son 1, de suma 2 y de producto 3, y si
P8 es 4 veces más lento, ¿Cuánto tarda el proceso total concurrente? ¿Cuál es el valor del speedup (Tiempo
secuencial/Tiempo paralelo)?. Modifique el código para lograr un mejor speedup.}

\begin{itemize}
    \item En este caso $strip = n/p = 128/8 = 16$
\end{itemize}

$Asignaciones = n^2 \times 16 + n \times 16 = 128^2 \times 16 + 128 \times 16 = 262144 + 2048 = 264192$

$Sumas = n^2 \times 16 = 128^2 \times 16 = 262144$

$Productos = n^2 \times 16 = 128^2 \times 16 = 262144$

Los procesos 1 a 7, tardaran lo mismo:

$264192 \times 1 ut + 262144 \times 2 ut + 262144 \times 3 ut = 1574912 ut$

El proceso 8, es 4 veces más lento que el resto. Por lo cual, tardará 4 veces más:

$1574912 ut \times 4 = 6299648 ut$

Por consiguiente, el proceso concurrente tardará $6299648 ut$ en finalizar. Ya que, el proceso 8 será el último, en terminar su trabajo.

Con las unidades de tiempo, de los procesadores más eficientes, el proceso secuencial tardará:

$2113536 \times 1 ut + 2097152 \times 2 ut + 2097152 \times 3 = 12599296 ut$

Por consiguiente el Speedup obtenido será de 2.

Para mejorar el Speedup podríamos balancear la carga de trabajo, de los procesadores, de manera distinta. Por ejemplo; haciendo que el procesador 8, el más lento, trabaje sobre un strip más pequeño.

\begin{itemize}
    \item Múltiplo de 7 más cercano a 128 $\rightarrow 126$
    \item Tamaño del stripe, para el procesador 8 $\rightarrow 128 - 126 = 2$
    \item Tamaño del stripe, para el resto de los procesadores $\rightarrow 126/7 = 18$
\end{itemize}

Asignaciones P$_{8} = 128^2 \times 2 + 128 \times 2 = 33024$

Sumas P$_{8} = 128^2 \times 2 = 32768$

Productos P$_{8} = 128^2 \times 2 = 32768$

Tiempo P$_8$ $= 33024 \times 1 ut + 32768 \times 2 ut + 32768 \times 3 = 196864 ut$

Asignaciones P$_{resto} = 128^2 \times 18 + 128 \times 18 = 297216$

Sumas P$_{resto} = 128^2 \times 18 = 294912$

Productos P$_{resto} = 128^2 \times 2 = 294912$

Tiempo P$_{resto}= 297216 \times 1 ut + 294912 \times 2 ut + 294912 \times 3 = 1771776 ut$

Con estos nuevos tiempos el speedup será de 7,1.

{\large \textbf{Dado el siguiente programa, indice si es posible que finalice.}}

\begin{lstlisting}
bool continue = true;
bool try = false;
co  while (continue) { try = true; try = false; } #(P)
/   <await(try) continue = false> #(Q)
oc
\end{lstlisting}

Con una política débilmente fair, el programa podría no terminar. Ya que, \emph{try} no se mantiene verdadera hasta ser vista por (Q).

Con una política fuertemente fair, el programa podría terminar. Ya que, \emph{try} se convierte en verdadera con infinita frecuencia.


\end{document}