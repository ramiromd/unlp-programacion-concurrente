\documentclass[a4paper, 10pt]{article}
\usepackage{common}
\usepackage{enumitem}
\newenvironment{QandA}{
    \begin{enumerate}\bfseries}
    {\end{enumerate}
}
\newenvironment{answered}{\par\normalfont}{}
\pagestyle{empty}

\begin{document}
    
% Carátula
\title{
    \faIcon[regular]{gem}\\
    Programación Concurrente\\
    \large Preguntas de final
}

\author{Ramiro Martínez D'Elía}
\date{2021}
\maketitle

\noindent%
\begin{QandA}
\item Defina programa concurrente, programa paralelo y programa distribuido.
\begin{answered}
    \emph{Apunte I: sección 1.1, Apunte II: sección 1.1 y Apunte IV: 1.1}
\end{answered}

%========================================================================

\item Responda
\begin{enumerate}[label=\alph*)]
\item ¿A qué se denomina propiedad del programa? ¿Qué son las propiedades de seguridad y vida? Ejemplificar.
\begin{answered}
    \emph{Apunte I: sección 1.1, Apunte II: sección 1.1 y Apunte IV: 1.1}
\end{answered}
\item Defina fairness. Relacionar dicho concepto con las políticas de scheduling.
\begin{answered}
    \emph{Apunte I: sección 1.7}
\end{answered}
\item Describa los distintos tipos de fairness
\begin{answered}
    \emph{Apunte I: sección 1.8}
\end{answered}
\item ¿Cuáles son las propiedades que debe cumplir un protocolo de E/S a una sección crítica?
\begin{answered}
    \emph{Apunte II: sección 1.2}
\end{answered}
\item Cuáles son los defectos que presenta la sincronización por busy waiting? Diferencie esta situación respecto de los semáforos.
\begin{answered}
    \emph{Apunte II: sección 2.3}
\end{answered}
\item Explique la semántica de la instrucción de grano grueso  AWAIT y su relación con las instrucciones Test \& Set o Fetch \& Add.
\begin{answered}
    \emph{Apunte I: sección 1.6}
\end{answered}
\end{enumerate}

%===================================================================================================

\item Definir el problema general de alocación de recursos y su resolución mediante una política SJN. ¿Minimiza el tiempo promedio de espera? ¿Es fair? Si no lo es, plantee una alternativa que lo sea.
\begin{answered}
    \emph{Apunte II: sección 3.5.2}
\end{answered}

%===================================================================================================

\item ¿En qué consiste la técnica de passing the baton? Aplicar este concepto a la resolución del problema de lectores y escritores.
\begin{answered}
    \emph{Apunte II: sección 3.5 y 3.5.1}
\end{answered}

%===================================================================================================

\item Explique el concepto de broadcast y sus dificultades de implementación en un ambiente distribuido, con pasaje de mensajes sincrónico y asincrónico.
\begin{answered}
\emph{Sobre primitiva broadcast $\rightarrow$ Apunte III: sección 2.1.4}

En un ambiente con memoria compartida, este tipo de primitivas es más sencilla de implementar. 

En ambientes distribuidos, al no haber variables compartidas, se debe utilizar Pasaje de Mensajes. Esto, supone ciertas dificultades para cada caso.

Con PMA:
\begin{itemize}
    \item Utilizar un único canal. El emisor deberá enviar tantos mensajes, como receptores existan. $\rightarrow$ Evita demoras inecesarias.
    \item Un canal por proceso. El emisor deberá enviar el mensaje por tantos canales, como receptores existan. $\rightarrow$ Causa demoras innesecarias: un proceso listo debe esperar a que el emisor itere sobre su canal. 
\end{itemize}

Con PMS:

Los canales son punto a punto. Por este motivo, solo podemos llevar a cabo la implementación PMA(2). Aunque, en este caso, resulte aún más ineficiente ya que \lstinline{send} causa demora.
\end{answered}

%====================================================================================================

\item Sobre exclusión mutua selectiva

\begin{enumerate}[label=\alph*)]
\item ¿Por qué el problema de los filósofos es de exclusión mutua selectiva? Si en lugar de 5 filósofos fueran 3, ¿el problema seguiría siendo de exclusión mutua selectiva? ¿Por qué?
\begin{answered}
    \emph{Apunte II: sección 3.4.1}
\end{answered}
\item El problema de los filósofos resuelto de forma centralizada y sin posiciones fijas ¿es de exclusión mutua selectiva? ¿Por qué?
\begin{answered}
    \emph{Apunte II: sección 3.4.1}
\end{answered}
\item El problema de los lectores-escritores es de exclusión mutua selectiva? ¿Porque?
\begin{answered}
    \emph{Apunte II: sección 3.4.2}
\end{answered}
\item Si en el problema de los lectores-escritores se acepta sólo 1 escritor  o 1 lector en la BD, ¿tenemos un problema de exclusión mutua selectiva?  ¿Por qué?
\begin{answered}
    \emph{Apunte II: sección 3.4.2}
\end{answered}
\end{enumerate}

%=====================================================================================================

\item Sea el problema en el cual N procesos poseen inicialmente cada uno un valor V, y el objetivo es que todos conozcan cual es el máximo y cuál es el mínimo de todos los valores.

\begin{enumerate}[label=\alph*)]
\item Plantee conceptualmente posibles soluciones con las siguientes arquitecturas de red: Centralizada, simétrica y anillo circular. No implementar.
\begin{answered}
    \emph{Apunte III: sección 2.1}
\end{answered}
\item Analice las soluciones anteriores desde el punto de vista del número de mensajes y la performance global del sistema.
\begin{answered}
    \emph{Apunte II: sección 2.1.4}
\end{answered}
\end{enumerate}

%======================================================================================================

\item Defina el concepto de granularidad. ¿Qué relación existe entre la granularidad de programas y de procesadores?
\begin{answered}
    \emph{Apunte IV: sección 1.6}
\end{answered}

%========================================================================================================

\item Dado el siguiente programa concurrente con memoria compartida, y suponiendo que todas las variables están inicializadas en 0 al empezar el programa, y que las instrucciones no son atómicas. Para cada una de las opciones indique verdadero o falso. En caso de ser verdadero indique el camino de ejecución para llegar a ese valor y de ser falso justifique claramente su respuesta.

\begin{multicols}{3}
\begin{lstlisting}
P1::            
If ( x == 0 ) then
    Y = 4*x+2;
    X = y+2+x;
\end{lstlisting}
\columnbreak
\begin{lstlisting}
P2::            
If ( x > 0 ) then
    X = X + 1;
\end{lstlisting}
\columnbreak
\begin{lstlisting}
P3::            
X = x*8+x*2+1;
\end{lstlisting}
\end{multicols}

\begin{enumerate}[label=\alph*)]
\item El valor de x al terminar el programa es 9.
\begin{answered}
\emph{Instrucciones no atómicas $\rightarrow$ los bloques IF pueden ser interrumpidos\\} 
Verdadero para la siguiente historia:\\
$P1_2 \rightarrow P2 \rightarrow P3 (x=1) \rightarrow P1_3 (y=2) \rightarrow P1_4 (x=9)$
\end{answered}
\item El valor de x al terminar el programa es 6.
\begin{answered}
Verdadero para la siguiente historia:\\
$P1_2 \rightarrow P1_3 (y=2) \rightarrow P3 (x=1) \rightarrow P1_4 (x=5) \rightarrow P2 (x=6)$
\end{answered}
\item El valor de x al terminar el programa es 11.
\begin{answered}
Falso: la única forma de que ocurra es que $x=1$ cuando se ejecute P3. Esto no puede darse, ya que P2 nunca podría incrementar con $x=0$ y P1 escribe valores mayores sobre $x$.
\end{answered}
\item Y, siempre termina con alguno de los siguientes valores: 10 o 6 o 2 o 0.
\begin{answered}
\begin{itemize}
\item $y=10$ con $P1_2 \rightarrow P3 (x=1) \rightarrow P2 (x=2) \rightarrow P1_3 (y=10) \rightarrow P1_4 (x=8)$
\item $y=6$ con $P1_2 \rightarrow P2 \rightarrow P3 (x=1) \rightarrow P1_3 (y=6) \rightarrow P1_4 (x=9)$
\item $y=2$ con cualquier historia que inicie con $P1_2 \rightarrow P1_3$. Una vez seteado $y$, ningún otra instrucción la modifica.
\item $y=0$ con cualquier historia que inicie con $P3$. Ya que $x=1$ invalidará el if de P1.
\end{itemize}
\end{answered}
\end{enumerate}

%=====================================================================================================

\item ¿En qué consiste la comunicación guardada (introducida por CSP) y cuál es su utilidad?
\begin{answered}
    \emph{Apunte III: sección 3.1}
\end{answered}

%=====================================================================================================

\item ¿Cuál es la utilidad de la técnica de passing the baton? ¿Qué relación encuentra con la técnica de passing the condition?
\begin{answered}
    \emph{Apunte II: sección 3.5}
\end{answered}

%=====================================================================================================

\item Explique sintéticamente los 7 paradigmas de interacción entre procesos en programación distribuida. Ejemplifique.
\begin{answered}
    \emph{Apunte III: capitulo 5}
\end{answered}

%=====================================================================================================

\item Responder sobre programación paralela
\begin{enumerate}
    \item ¿Cuál es el objetivo de la programación paralela?
    \begin{answered}
        \emph{Apunte IV: sección 1.1}
    \end{answered}
    \item Defina las métricas de speedup y eficiencia. ¿Cuál es el significado de cada una de ellas (que miden)? ¿Cuál es el rango de valores para cada una?
    \begin{answered}
        \emph{Apunte IV: sección 1.2 y sección 1.3}
    \end{answered}
    \item ¿En qué consiste la ley de Amdahl?
    \begin{answered}
        \emph{Apunte IV: sección 1.5}
    \end{answered}
\end{enumerate}

%=======================================================================================================

\item Sea el problema de ordenar de menor a mayor un arreglo de A[1..n] 

\begin{enumerate}[labelindent=0pt, align=left, leftmargin=0pt]
\item Escriba un programa donde dos procesos (cada uno con n/2 valores) realicen la operación en paralelo mediante una serie de intercambios. 
\begin{answered}
En la siguiente implementación, el proceso P1 se queda con los números más chicos en su porción del arreglo. Mientras que, el proceso P2 con los números más grandes.
\begin{lstlisting}[multicols=2]
Process P1
const mayor = n/2;
int nuevo,
    a1[1:n/2];

# ordenar a1 de forma ascendente

P2 ! (a1[mayor]); # (1)
P2 ? (nuevo);

do (true) a1[mayor] > nuevo ->
    # reordenar a1:
    # decartando a1[mayor]
    P2 ! (a1[mayor]);
    P2 ? (nuevo)
od
end;
Process P2
const menor = 1;
int nuevo,
    a1[1:n/2];

# ordenar a1 de forma ascendente

P1 ? (nuevo);
P1 ! (a1[menor]); # (2)

do (true) a1[menor] < nuevo ->
    # reordenar a1:
    # descartando a1[menor]
    P1 ? (nuevo);
    P1 ! (a2[menor]);
od
end;
\end{lstlisting}
\end{answered}
\item ¿Cuántos mensajes intercambian en el mejor de los casos? ¿Y en el peor de los casos? 
\begin{answered}
\textbf{Mejor de los casos} $\rightarrow$ 2 mensajes totales (uno cada proceso).
\\
La lista ya se encuentra ordenada. Solo se envían los mensajes (1) y (2). Los valores enviados no satifacen la guarda del do, causando su finalización.
\\
\textbf{Peor de los casos} $\rightarrow n$ mensajes totales.
\\
La lista está ordenada de mayor a menor, todos los valores son intercambiados ($n/2$ cada proceso).
\end{answered}
\item Implemente una solución general a $k$ procesos, con $n/k$ valores cada uno (\emph{odd-even/exchange sort})
\begin{answered}
\begin{lstlisting}
Process worker[i = 1..k]

int largest = n/k, smallest = 1,
    a[1:k], dato;

# Ordeno la porcion del arreglo
# del proceso actual.

for(ronda = 1; ronda <= k; ronda++)

    if (i mod 2 == ronda mod 2)
        # Misma paridad (proceso+ronda par o proceso+ronda impar)
        if (i != k)
            proc[i+1]!(a[largest]);
            proc[i+1]?(dato);

            while (a[largest] > dato)
                # Inserto dato ordenado, pisando a[largest].
                proc[i+1]!(a[largest]);
                proc[i+1]?(dato);
            end;
        end;
    else
        if (i != 1)
            proc[i-1]?(dato);
            proc[i-1]!(a[smallest]);

            while (a[smallest] < dato)
                # inserto dato ordenado, pisando a[smallest].
                proc[i-1]?(dato);
                proc[i-1]!(a[smallest]);
            end;
        end;
    end;
end;
End.
\end{lstlisting}
\end{answered}
\item ¿Cuántos mensajes se intercambian en (c) en el mejor caso? ¿Y en el peor de los casos?
\begin{answered}
    \textbf{Peor caso} $\rightarrow$ la lista está ordenada de forma descendente (mayor a menor). En cuyo caso, los procesos deben intercambiar todos sus valores (en cada ronda). Por ejemplo, con $n=8$ y $k=4$:
    \\
    $\#MensajesRondasImpares = \#NumsPorProceso * \#ProcesosActivos * \#Rondas$
    \\
    $\#MensajesRondasImpares = n/k * k * k/2 = 8/4 * 4 * 4/2 = 2 * 4 * 2 = 16$ 
    \\
    $\#MensajesRondasPares = \#NumsPorProceso * \#ProcesosActivos - 2 * \#Rondas$
    \\
    $\#MensajesRondasPares = n/k * k-2 * k/2 = 8/4 * 4-2 * 4/2 = 2 * 2 * 2 = 8$ 
    \\
    $\#Mensajes = \#MensajesRondasPares + \#MensajesRondasImpares = 8 + 16 = 24$
    \\
    \textbf{Mejor caso} $\rightarrow$ la lista está ordenada de forma ascendente (menor a mayor). Seguimos la misma lógica, del caso anterior, pero entendiendo que cada proceso solo intercambia 1 único valor por ronda. Por ejemplo, con $n=8$ y $k=4$:
    \\
    $\#MensajesRondasImpares = 1 * k * k/2 = 1 * 4 * 4/2 = 1 * 4 * 2 = 8$
    \\
    $\#MensajesRondasPares = 1 * k-2 * k/2 = 1 * 4-2 * 4/2 = 1 * 2 * 2 = 4$
    \\
    $\#Mensajes = \#MensajesRondasPares + \#MensajesRondasImpares = 8 + 4 = 12$
\end{answered}

\item ¿Cómo modificaría el algoritmo del punto (c) para que termine tan rápido como el arreglo este ordenado? ¿Esto agrega overhead de mensajes? De ser así, ¿Cuánto?
\begin{answered}
Se podría implementar un proceso coordinador para lograr la siguiente interacción:. Al final de cada ronda, los procesos le indican al coordinador si efectuaron cambios en su colección de números
\begin{itemize}
    \item Los procesos, al final de cada ronda, le notifican al coordinador si efectuaron cambios en su colección de números.
    \item Si el coordinador, para una ronda, no recibe ninguna notificación de cambios entonces; da por concluido el trabajo y notifica a los procesos.
\end{itemize}
Esto, claramente, agrega un overhead en el pasaje de mensajes. Ya que, luego de cada ronda el coordinador recibirá $k$ mensajes (1 por proceso) y envará otros $k$ mensajes (1 a cada proceso). Dando un overhead, total, de $2k$
\end{answered}
\item ¿Considere que es más adecuado para este caso, si pasaje de mensajes sincrónico o asincrónico? Justifique.
\begin{answered}
PMS resulta la opción más adecuada ya que los procesos deben sincronizar de a pares. El comportamiento bloqueante del send/receive produce, de forma implícita, una barrera simética.
\\
En caso de emplear PMA, deberíamos implementar de forma explicita la barrera simétrica.
\end{answered}
\end{enumerate}

\item Suponga que quiere ordenar N números enteros utilizando pasaje de mensajes con el siguiente algoritmo (odd/even Exchange sort): Hay  n procesos P [1: n], con n par. Cada proceso ejecuta una serie de rondas. En las rondas impares, los procesos con número impar P[impar] intercambian valores con P [impar +1] si los números están desordenados. En las rondas pares, los procesos con numero par P[par] intercambian valores con P [par +1] si los números están desordenados (P [1] y P[n] no hacen nada en las rondas pares).
\begin{enumerate}
    \item Determine cuantas rondas deben ejecutarse en el peor caso para ordenar los números.
    \begin{answered}
        \textbf{Peor caso} $\rightarrow$ la lista está ordenada de forma descendente (mayor a menor).
        \\
        En este caso, el algoritmo requerirá de $n$ rondas. Ya que requiere, enviar el máximo valor $n$ posiciones hacia delante. Con el valor mínimo, ocurre lo mismo; es necesario moverlo $n$ posiciones hacia atrás. Ambos desplazamientos se dan en simultáneo.
    \end{answered}
    \item ¿Considere que es más adecuado para este caso, si pasaje de mensajes sincrónico o asincrónico? Justifique.
    \begin{answered}
        \emph{Misma respuesta que en el caso general para $k$ procesos.}
    \end{answered}
\end{enumerate}
\end{QandA}
\end{document}